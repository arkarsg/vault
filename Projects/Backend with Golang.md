---
title: Backend with Golang
tags: [swe, backend]
---

>[!note] repo
>Repo is linked [here](https://github.com/arkarsg/split.git)

---

>[!warning] TO DO
>- [ ] Mocking
>- [x] Config with Viper

| Component           | Tool       |
| ------------------- | ---------- |
| Database            | `Postgres` |
| Migration           | `migrate`  |
| ORM                 | `sqlc`     |
| Web framework       | `Gin`      |
| Integration testing | `testcontainers`           |

---

# Setting up the database
First, define a schema and its relationships.

Then, create the database in Docker. Map the container ports to hosts ports accordingly.

Manage the migrations with `migrate`. With `migrate`, developers have to define `up` migration and `down` migration.

>[!warning] Pitfalls of creating databases in Docker and Kubernetes
>https://vonng.com/cn/blog/en/db-in-k8s/

---
# Backend
`sqlc` was used as an ORM

### What is SQLC?
`sqlc` is a SQL-first ORM. Developers define SQL queries and `sqlc` generates type-safe, idiomatic Go code.

>[!note] More on ORMs and SQLC
>- [ORMs](https://encore.dev/resources/go-orms)
>- [SQLC](https://encore.dev/blog/go-get-it-001-sqlc)

#### Testing code generated by SQLC
Wrote tests for code generated by `sqlc`. Note that this is not strictly a *unit test* since it is interacting with a database.

**Why do we need to test code generated by library?**
- When a system fails, it is good to know where it fails to react as well as add it as part of test case to prevent future occurrences
- *trust but verify* when using code-gen. It is a single point of failure that is easily caught
- Testing data access without making assumptions about what libraries you are using.
- Useful for scenarios where you want to swap out ORMs (sqlc → GORM), support multiple backends; and ascertain that there are no differences in behaviour/ performance

### Using `testcontainers`
So far, running tests for code generated by `sqlc` will write to database container that was created. This means that our tests will be *stateful*.
**How can we create an isolated database environment for our test suite to run?**

- Using `testcontainers`, we can create a `postgres` container. This container will be used by `main_test` inside the `db` package.
- A custom port mapping maps port `5432` of the container to a random available port in the host.

**How can we create the schema in the container?**
`migrate` also has API for Golang. Therefore, we can perform migrations within the code, as long as we have the migration `sql` files and DB URL.

An overview of creating the test database is as follows:

```go

func SetUpTestDatabase() *TestDatabase {
	c, cancel := context.WithTimeout(context.Background(), time.Second*60)
	container, dbInstace, dbAddr, err := createContainer(c)
	if err != nil {
		log.Fatal("Failed to set up test database", err)
	}

	err = migrateDb(dbAddr)
	if err != nil {
		log.Fatal("Failed to perform migration: ", err)
	}
	cancel()

	return &TestDatabase{
		container:  container,
		DbInstance: dbInstace,
		DbAddress:  dbAddr,
	}
}

func (t *TestDatabase) TearDown() {
	t.DbInstance.Close()
	_ = t.container.Terminate(context.Background())
}

```

### Isolation levels in RDBMS

There are Four Types of Isolation Levels:
1. **Read Uncommitted:** The lowest level. Row updates are halted if a prior transaction made an uncommitted update to that row.
2. **Read Committed:** This prevents "dirty reads." If a transaction has already been changed but has not yet been committed, this prevents any further reads or writes.
3. **Repeatable Read:** This level prevents the read row from being viewed and potentially modified.
4. **Serializable:** The most severe level of isolation, serializable often locks a complete database rather than a single row of data.

---

#### `FOR UPDATE` clause

##### Lost update
Without `FOR UPDATE`, two or more transactions might read the same data and subsequently update it, leading to one transaction's updates being overwritten by another's.

```sql
--- transaction 1 ---
BEGIN;
SELECT balance FROM accounts WHERE account_id = 1; -- Reads balance as 100
UPDATE accounts SET balance = balance + 50 WHERE account_id = 1; -- Sets balance to 150
COMMIT;

--- transaction 2 ---
BEGIN;
SELECT balance FROM accounts WHERE account_id = 1; -- Reads balance as 100 (same as T1)
UPDATE accounts SET balance = balance - 30 WHERE account_id = 1; -- Sets balance to 70
COMMIT;

```

Suppose these 2 transactions occur at the same time. Without `FOR UPDATE`, the row is not locked. Therefore, the final balance would read `70` from the second transaction instead of `120`.

##### Dirty reads
Without `FOR UPDATE`, one transaction might read data that is being modified by another transaction but has not yet been committed, leading to inconsistencies.

```sql
BEGIN;
UPDATE accounts SET balance = balance + 50 WHERE account_id = 1; -- Updates balance but hasn't committed
-- Balance is now 150, but T1 hasn't committed

BEGIN;
SELECT balance FROM accounts WHERE account_id = 1; -- Reads balance as 150
-- T2 assumes balance is 150, but T1 might roll back later
```

If transaction 1 rolls back, transaction 2 will before operations on incorrect data, leading to inconsistent application state.

##### Non-repeatable reads
A transaction might read the same row twice and get different values because another transaction modified the data in the interim.

```sql
BEGIN;
SELECT balance FROM accounts WHERE account_id = 1; -- Reads balance as 100
-- Some operations
SELECT balance FROM accounts WHERE account_id = 1; -- Reads balance again, could be different if T2 modifies it


BEGIN;
UPDATE accounts SET balance = balance + 50 WHERE account_id = 1; -- Changes balance to 150
COMMIT;
```

The 2 `balance` in transaction 1 could be different.

##### Phantom Reads
A transaction might see new rows inserted by another transaction in subsequent reads

```sql
BEGIN;
SELECT COUNT(*) FROM orders WHERE customer_id = 1; -- Returns 5 orders
-- Some operations
SELECT COUNT(*) FROM orders WHERE customer_id = 1; -- Returns 6 orders if T2 inserts a new order

BEGIN;
INSERT INTO orders (customer_id, product_id, quantity) VALUES (1, 101, 1); -- Inserts new order for customer 1
COMMIT;

```

---

Therefore, `FOR UPDATE` clause is necessary to lock the row for any read/ write operations in a transaction. However, this does not solve the problems of deadlock.

>[!note] Why?
>Deadlocks occur when two or more transactions are indefinitely waiting for resources held by each other, creating a *circular wait* condition.
>
>`FOR UPDATE` clause does not prevent that possibility

---

### Deadlocks in RDBMS

```sql
--- trasaction 1
BEGIN;
SELECT * FROM table_a WHERE id = 1 FOR UPDATE; -- Locks row in table_a
-- Some operations
SELECT * FROM table_b WHERE id = 2 FOR UPDATE; -- Waits for row in table_b (held by T2)

--- transaction 2
BEGIN;
SELECT * FROM table_b WHERE id = 2 FOR UPDATE; -- Locks row in table_b
-- Some operations
SELECT * FROM table_a WHERE id = 1 FOR UPDATE; -- Waits for row in table_a (held by T1)

```

1. `T1` locks a row in `table_a` and waits for a row in `table_b`
2. `T2` locks a row in `table_b` and waits for a row in `table_a`

This creates a circular wait, leading to a deadlock

#### Resolving deadlocks
- **Resource ordering**
	- Transactions must request resources in a predefined order, avoiding circular waits:
	- **Linear Resource Acquisition**: When all transactions follow the same order for acquiring resources, the possibility of a circular wait condition is eliminated. If T1 has acquired a lock on `table_a` and is waiting for `table_b`, T2 cannot start by locking `table_b` and then wait for `table_a`; T2 must also start by locking `table_a`.

>[!note] **Lock Granularity**
>Deadlocks can occur at different levels (e.g., row, page, table). `FOR UPDATE` addresses row-level locking, but deadlocks can involve multiple levels of locking.

---

# Auth

Storing password in DBs:
- Hash with `bcrypt`

`cost` parameter is the number of iterations
`salt` is a random salt that is added

4 components:
1. ALG : the algorithm
2. Cost : number of iterations
	- For example, `cost=10` => $2^{10} = 1024$ key expansion rounds
3. `salt` is a length of 16 bytes base64 encoded value
4. `hash` is a length of 24 bytes

This creates a hash string that is stored in the database.

When users login, the password input by the user is hashed with the same cost and salt. If it is the same, then the password is correct.

---

When we hash the same password twice, the 2 hash values are different.

A random salt value is generated and is used to generate the bcrypt hash.

---

# Custom matchers for `gomock`

Some use cases for custom `gomock` matchers:
1. Object we want to match has `time.now()` field which is different on every run
2. We want to create an account with plain-text password and match against hashed password to be stored in the DB

`gomock` matcher has the following interface:
```go
type Matcher interface {
	// Matches returns whether x is a match.
	Matches(x interface{}) bool
	// String describes what the matcher matches.
	String() string
}
```

Therefore, we can create our own `matcher` by implementing the `Matches` and `String` methods

In case 1, our `Matches` method can match all field except the timestamp
In case 2, our `Matches` method can use `CheckHashPassword` function in `bcrypt` instead of plain-text comparison

---

# PASETO vs JWT
- [JWT and PASETO](JWT%20and%20PASETO.md)

---

# Configs with `Viper`

[Viper](https://github.com/spf13/viper) is an application configuration solution that lets you load env vars from different formats and sources. Here, an example with `yaml` is demonstrated.

Let’s define a `yaml` file with the desired configs without worrying about how `Viper` will read the contents:

```yaml
db:
  dev_db:
    db_user: root
    db_password: password
    db_driver: postgres
    db_name: split_db
    db_port: "5432"
  testcontainers_db:
    db_user: testuser
    db_password: testpassword
    db_driver: postgres
    db_name: split_test_db
    db_port: "5432"
server:
  path: "0.0.0.0"
  port: "8080"
token:
  symmetric_key: <symmetric-key>
  access_duration: 15m
```

We have `db`, `server`, and `token` as the main *dictionary* keys. 
- `db` consists of 2 dictionaries: `dev_db` and `testcontainers_db`
- `server` consists of 2 key-value pairs
- `token` consists of 2 key-value pairs

Viper uses `mapstructure` to map the contents of a *dictionary* into a struct object.

Suppose for `server`, it has to unmarshal the `server` key into a struct that contains `path` and `port`

```go
type ServerEnvs struct {
	Path    string `mapstructure:"path"`
	Port    string `mapstructure:"port"`
	Address string // Derived field.
}

type TokenEnvs struct {
	SymmetricKey   string        `mapstructure:"symmetric_key"`
	AccessDuration time.Duration `mapstructure:"access_duration"`
}
```

### What about nested dictionaries like `db`?

First, we define a struct that can hold values of each dictionary in `db`:
```go
type DbEnvs struct {
	DbUser     string `mapstructure:"db_user"`
	DbPassword string `mapstructure:"db_password"`
	DbDriver   string `mapstructure:"db_driver"`
	DbName     string `mapstructure:"db_name"`
	DbPort     string `mapstructure:"db_port"`
}
```

Then, this is wrapped in `map[string]*DbEnvs` where a `string` is the key, such as `dev_db` or `testcontainers_db`:

```go
type ServerConfig struct {
	Db     map[string]*DbEnvs
	Server ServerEnvs
	Token  TokenEnvs
}
```

Now, we have a struct that can be used to unmarshal the config.

```go
func init() {
	_, filename, _, _ := runtime.Caller(0)
	configPath := filepath.Join(filepath.Dir(filename), "..")

	viper.AddConfigPath(configPath)
	viper.SetConfigName("config")
	viper.SetConfigType("yaml")

	if err := viper.ReadInConfig(); err != nil {
		log.Fatalf("Can't find config.yaml file: %v", err)
	}

	if err := viper.Unmarshal(&config); err != nil {
		log.Fatalf("Failed to unmarshal configuration: %v", err)
	}

	config.Server.Address = fmt.Sprintf("%s:%s", config.Server.Path, config.Server.Port)
}
```

### Misc notes
Suppose the module to load config is in `./utils/config.go` belonging to `package utils` and `config.yaml` resides in `./`. How can we retrieve the absolute file path that works for Go in any environment?

Simply using `os.Getwd()` does not work because it returns the working directory of the user executing the process and not the directory of the file.

---

#### `func init()` in Go

These `init()` functions can be used within a `package` block and regardless of how many times that package is imported, the `init()` function will only be called once.

`init()` function would be preferential when compared to having to explicitly call your own setup functions.

---